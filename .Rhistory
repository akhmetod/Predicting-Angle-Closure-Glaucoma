summary(my.logit)
# Check Accuracy
my.pred <- predict(my.logit, type="response")
my.pred <- sapply(my.pred, function(p){
if(p>0.5) return("YES")
else return("NO")
})
sum(my.pred == my.data[,21]) / length(my.pred)
x <- data.matrix(my.data[,-21])
y <- factor(my.data[,21])
my.logit = glmnet(x, y, family = "binomial", alpha=1)
plot(my.logit, xvar = "dev", label = TRUE)
my.cv = cv.glmnet(x, y, family = "binomial", type.measure = "class")
plot(my.cv)
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
coef(my.cv, s = "lambda.1se")
# Clear memory and load packages
rm(list=ls())
library(glmnet)
library(ggplot2)
# Read data, remove columns, clean NA rows
my.data <- read.csv("AngleClosure.csv")
my.data <- my.data[,-c(1,15,16)]
my.data <- my.data[complete.cases(my.data),]
my.data[,-21] <- data.matrix(my.data[,-21])
my.data[,21] <- factor(my.data[,21])
row.names(my.data) <- NULL
# Exploratory analysis of the data
ggplot(data=my.data, aes(x=ANGLE.CLOSURE, y=AOD750)) +
geom_boxplot(shape=1)
x <- data.matrix(my.data[,-21])
y <- factor(my.data[,21])
my.logit = glmnet(x, y, family = "binomial", alpha=1)
plot(my.logit, xvar = "dev", label = TRUE)
my.cv = cv.glmnet(x, y, family = "binomial", type.measure = "class")
plot(my.cv)
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
coef(my.cv, s = "lambda.1se")
my.logit <- glm(ANGLE.CLOSURE ~., data=my.data, family="binomial")
my.pred <- predict(my.logit, type="response")
my.pred <- sapply(my.pred, function(p){
if(p>0.5) return("YES")
else return("NO")
})
sum(my.pred == my.data[,21]) / length(my.pred)
my.logit <- glm(ANGLE.CLOSURE ~ AOD750 + TISA750 + ACA + ACV +
LENSVAULT + ASPH, data=my.data, family="binomial")
# Check Accuracy
my.pred <- predict(my.logit, type="response")
my.pred <- sapply(my.pred, function(p){
if(p>0.5) return("YES")
else return("NO")
})
sum(my.pred == my.data[,21]) / length(my.pred)
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "response")
my.pred
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "response")
logloss <- 0
for(i in 1:length(y)) {
if(y[i]=="YES") logloss <- logloss + log(my.pred[i])
else logloss <- logloss + log(1-my.pred[i])
}
logloss <- -logloss/length(y)
logloss
myData=read.csv("semeion.csv",header=FALSE)
rm(list=ls())
myData=read.csv("semeion.csv",header=FALSE)
# Build data matrix with (thresholded) pixel and label data
myX=data.matrix(myData[,1:256])
myLabel=factor(apply(myData[,257:266],1,function(xx){
return(which(xx=="1")-1)
}))
dataStar=data.frame(myLabel,myX)
library(nnet)
nFolds=10
myLabel
View(myX)
View(dataStar)
Read handwritten digits data
myData=read.csv("semeion.csv",header=FALSE)
# Build data matrix with (thresholded) pixel and label data
myX=data.matrix(myData[,1:256])
myLabel=factor(apply(myData[,257:266],1,function(xx){
return(which(xx=="1")-1)
}))
dataStar=data.frame(myLabel,myX)
library(nnet)
nFolds=10
nIter=25
myLambdas=10^seq(-1,5,1)
ErrRates=matrix(NA,nIter,length(myLambdas))
testingIndices=sample(length(myLabel))[1:round(length(myLabel)/nFolds)]
myDataTesting=dataStar[testingIndices,]
myDataTraining=dataStar[-testingIndices,]
# Clear memory and load packages
rm(list=ls())
library(nnet)
# Read data, remove columns, clean NA rows
my.data <- read.csv("AngleClosure.csv")
my.data <- my.data[,-c(1,15,16)]
my.data <- my.data[complete.cases(my.data),]
my.data[,-21] <- data.matrix(my.data[,-21])
my.data[,21] <- factor(my.data[,21])
row.names(my.data) <- NULL
# Read handwritten digits data
myData=read.csv("semeion.csv",header=FALSE)
# Build data matrix with (thresholded) pixel and label data
myX=data.matrix(myData[,1:256])
myLabel=factor(apply(myData[,257:266],1,function(xx){
return(which(xx=="1")-1)
}))
dataStar=data.frame(myLabel,myX)
library(nnet)
nFolds=10
nIter=25
myLambdas=10^seq(-1,5,1)
ErrRates=matrix(NA,nIter,length(myLambdas))
for(iter in 1:nIter){
testingIndices=sample(length(myLabel))[1:round(length(myLabel)/nFolds)]
myDataTesting=dataStar[testingIndices,]
myDataTraining=dataStar[-testingIndices,]
for(lambda in myLambdas){
fit=nnet(myLabel~.,data=myDataTraining,weights=rep(1,length(myLabel)),size=10,
decay=lambda,MaxNWts=10000,maxit=250)
myPreds=apply(predict(fit,newdata=myDataTesting),1,which.max)-1
ErrRates[iter,myLambdas==lambda]=mean(myDataTesting$myLabel!=myPreds)
}
}
# Clear memory and load packages
rm(list=ls())
library(nnet)
# Read data, remove columns, clean NA rows
my.data <- read.csv("AngleClosure.csv")
my.data <- my.data[,-c(1,15,16)]
my.data <- my.data[complete.cases(my.data),]
my.data[,-21] <- data.matrix(my.data[,-21])
my.data[,21] <- factor(my.data[,21])
row.names(my.data) <- NULL
View(my.data)
fit <- nnet(x,y)
# Arrange the data
x <- data.matrix(my.data[,-21])
y <- factor(my.data[,21])
fit <- nnet(x,y)
fit <- nnet(x,y,size=10)
fit <- nnet(x,y,size=2)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=2)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=10)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=20)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=50)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=30)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=25)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=20)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=15)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=18)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=22)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=21)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=19)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=20)
summary(fit)
source_url('https://gist.githubusercontent.com/fawda123/7471137/raw/466c1474d0a505ff044412703516c34f1a4684a5/nnet_plot_update.r')
library(devtools)
install.packages("devtools")
library(devtools)
source_url('https://gist.githubusercontent.com/fawda123/7471137/raw/466c1474d0a505ff044412703516c34f1a4684a5/nnet_plot_update.r')
plot.nnet(fit)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=10)
library(nnet)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=10)
plot.nnet(fit)
wts.in<-fit$wts
struct<-fit$n
plot.nnet(wts.in,struct=struct)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=2)
plot.nnet(fit)
wts.in<-fit$wts
struct<-fit$n
plot.nnet(wts.in,struct=struct)
source_url('https://gist.github.com/fawda123/6206737/raw
/2e1bc9cbc48d1a56d2a79dd1d33f414213f5f1b1/gar_fun.r')
rel.imp<-gar.fun('Y1',fit,bar.plot=F)$rel.imp
cols<-colorRampPalette(c('green','red'))(num.vars)[rank(rel.imp)]
predict(fit, my.data, type = "class")
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=20)
plot.nnet(fit)
predict(fit, my.data, type = "class")
my.pred <- predict(fit, my.data, type = "class")
my.pred == my.data[,21]
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=10)
my.pred <- predict(fit, my.data, type = "class")
my.pred == my.data[,21]
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=20)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=50)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=15)
sum(my.pred == my.data[,21]) / length(my.pred)
my.pred <- predict(fit, my.data, type = "class")
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=10)
sum(my.pred == my.data[,21]) / length(my.pred)
my.pred <- predict(fit, my.data, type = "class")
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=5)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=3)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=2)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=1)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=2)
my.pred <- predict(fit, my.data, type = "class")
my.pred
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=3)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=4)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=4)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=5)
sum(my.pred == my.data[,21]) / length(my.pred)
my.pred <- predict(fit, my.data, type = "class")
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=6)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=7)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=8)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
for(i in 1:30) {
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=i)
my.pred <- predict(fit, my.data, type = "class")
accuracy[i] <- sum(my.pred == my.data[,21]) / length(my.pred)
}
accuracy <- rep(0,30)
for(i in 1:30) {
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=i)
my.pred <- predict(fit, my.data, type = "class")
accuracy[i] <- sum(my.pred == my.data[,21]) / length(my.pred)
}
plot(seq(30),accuracy)
which.max(accuracy)
my.size <- which.max(accuracy)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=my.size)
my.pred <- predict(fit, my.data, type = "class")
accuracy[i] <- sum(my.pred == my.data[,21]) / length(my.pred)
plot.nnet(fit)
accuracy
sum(my.pred == my.data[,21]) / length(my.pred)
for(i in 1:30) {
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=i)
my.pred <- predict(fit, my.data, type = "class")
accuracy[i] <- sum(my.pred == my.data[,21]) / length(my.pred)
}
plot(seq(30),accuracy)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
plot.nnet(fit)
plot(seq(30),accuracy)
?cv.glmnet
# Clear memory and load packages
rm(list=ls())
library(glmnet)
library(ggplot2)
?cv.glmnet
# Read data, remove columns, clean NA rows
my.data <- read.csv("AngleClosure.csv")
my.data <- my.data[,-c(1,15,16)]
my.data <- my.data[complete.cases(my.data),]
my.data[,-21] <- data.matrix(my.data[,-21])
my.data[,21] <- factor(my.data[,21])
row.names(my.data) <- NULL
# Arrange the data
x <- data.matrix(my.data[,-21])
y <- factor(my.data[,21])
my.cv = cv.glmnet(x, y, family = "binomial", nfolds=10,
type.measure = "class")
plot(my.cv)
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
coef(my.cv, s = "lambda.1se")
coef(my.cv, s = "lambda.min")
my.pred <- predict(my.cv, newx = x, s = "lambda.1st", type = "class")
sum(y == my.pred) / length(my.pred)
my.pred <- predict(my.cv, newx = x, s = "lambda.1st", type = "class")
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
coef(my.cv, s = "lambda.min")
# Clear memory and load packages
rm(list=ls())
library(glmnet)
library(ggplot2)
# Read data, remove columns, clean NA rows
my.data <- read.csv("AngleClosure.csv")
my.data <- my.data[,-c(1,15,16)]
my.data <- my.data[complete.cases(my.data),]
my.data[,-21] <- data.matrix(my.data[,-21])
my.data[,21] <- factor(my.data[,21])
row.names(my.data) <- NULL
# Exploratory analysis of the data
ggplot(data=my.data, aes(x=ANGLE.CLOSURE, y=AOD750)) +
geom_boxplot(shape=1)
# -------------------- Fitting Logistic Model -------------------- #
# Arrange the data
x <- data.matrix(my.data[,-21])
y <- factor(my.data[,21])
my.cv = cv.glmnet(x, y, family = "binomial", , alpha=0.5,
nfolds=10, type.measure = "class")
plot(my.cv)
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
coef(my.cv, s = "lambda.min")
my.cv = cv.glmnet(x, y, family = "binomial", , alpha=1,
nfolds=10, type.measure = "class")
plot(my.cv)
my.pred <- predict(my.cv, newx = x, s = "lambda.1st", type = "class")
my.pred <- predict(my.cv, newx = x, s = "lambda.1se", type = "class")
sum(y == my.pred) / length(my.pred)
coef(my.cv, s = "lambda.1se")
my.cv = cv.glmnet(x, y, family = "binomial", , alpha=0.5,
nfolds=10, type.measure = "class")
plot(my.cv)
my.pred <- predict(my.cv, newx = x, s = "lambda.1se", type = "class")
sum(y == my.pred) / length(my.pred)
coef(my.cv, s = "lambda.1se")
coef(my.cv, s = "lambda.min")
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
# Find coefficients
coef(my.cv, s = "lambda.min")
my.cv = cv.glmnet(x, y, family = "binomial", , alpha=0.5,
nfolds=30, type.measure = "class")
plot(my.cv)
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
coef(my.cv, s = "lambda.min")
my.pred <- predict(my.cv, newx = x, s = "lambda.1se", type = "class")
sum(y == my.pred) / length(my.pred)
# Find coefficients
coef(my.cv, s = "lambda.1se")
?cv.glmnet
my.cv = cv.glmnet(x, y, family = "binomial", , alpha=0.5,
nfolds=50, type.measure = "class")
plot(my.cv)
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
my.cv = cv.glmnet(x, y, family = "binomial", , alpha=0.5,
nfolds=100, type.measure = "class")
plot(my.cv)
plot(my.cv)
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
coef(my.cv, s = "lambda.min")
my.cv = cv.glmnet(x, y, family = "binomial", , alpha=0.5,
nfolds=50, type.measure = "class")
plot(my.cv)
# Compute mis-classification rate
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
my.cv = cv.glmnet(x, y, family = "binomial", , alpha=1,
nfolds=50, type.measure = "class")
plot(my.cv)
# Compute mis-classification rate
my.pred <- predict(my.cv, newx = x, s = "lambda.min", type = "class")
sum(y == my.pred) / length(my.pred)
# Find coefficients
coef(my.cv, s = "lambda.min")
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=0.1, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
plot.nnet(fit)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=0.01, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
, s
, s
, s
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=1, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=10, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=100, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=1000, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=100, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=10, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=1, size=29)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
seq(-2,3,0.5)
seq(-2,3,0.3)
seq(-2,3,0.15)
seq(-2,3,0.16)
seq(-2,3,0.17)
my.decay <- seq(-2,3,0.17)
for(i in 1:30) {
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=my.decay[i], size=20)
my.pred <- predict(fit, my.data, type = "class")
accuracy[i] <- sum(my.pred == my.data[,21]) / length(my.pred)
}
my.decay <- seq(-2,3,0.17)
accuracy <- rep(0,30)
for(i in 1:30) {
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=my.decay[i], size=20)
my.pred <- predict(fit, my.data, type = "class")
accuracy[i] <- sum(my.pred == my.data[,21]) / length(my.pred)
}
plot(seq(30),accuracy)
my.decay
my.decay <- 10^my.decay
my.decay
accuracy <- rep(0,30)
for(i in 1:30) {
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=my.decay[i], size=20)
my.pred <- predict(fit, my.data, type = "class")
accuracy[i] <- sum(my.pred == my.data[,21]) / length(my.pred)
}
plot(seq(30),accuracy)
my.decay[16]
fit <- nnet(ANGLE.CLOSURE ~., data=my.data, decay=3.5, size=20)
my.pred <- predict(fit, my.data, type = "class")
sum(my.pred == my.data[,21]) / length(my.pred)
# Clear memory and load packages
rm(list=ls())
library(glmnet)
library(ggplot2)
# Read data, remove columns, clean NA rows
my.data <- read.csv("AngleClosure.csv")
my.data <- my.data[,-c(1,15,16)]
my.data <- my.data[complete.cases(my.data),]
my.data[,-21] <- data.matrix(my.data[,-21])
my.data[,21] <- factor(my.data[,21])
row.names(my.data) <- NULL
View(my.data)
ggplot(my.data, aes(x=AOD750, y=TISA750, color=ANGEL.CLOSURE)) +
geom_point(shape=1)
ggplot(my.data, aes(x=AOD750, y=TISA750, color=ANGLE.CLOSURE)) +
geom_point(shape=1)
ggplot(my.data, aes(x=AOD750, y=TISA750, color=ANGLE.CLOSURE)) +
geom_point(shape=0.5)
ggplot(my.data, aes(x=AOD750, y=TISA750, color=ANGLE.CLOSURE)) +
geom_point()
ggplot(my.data, aes(x=AOD750, y=IT750, color=ANGLE.CLOSURE)) +
geom_point()
ggplot(my.data, aes(x=AOD750, y=ACA, color=ANGLE.CLOSURE)) +
geom_point()
ggplot(my.data, aes(x=AOD750, y=ACV, color=ANGLE.CLOSURE)) +
geom_point()
ggplot(my.data, aes(x=TISA750, y=ACV, color=ANGLE.CLOSURE)) +
geom_point()
ggplot(my.data, aes(x=ACA, y=ACV, color=ANGLE.CLOSURE)) +
geom_point()
library(stats)
?prcomp()
prcomp(my.data[,-21], scale.=T)
my.pca <- prcomp(my.data[,-21], scale.=T)
my.pca$Rotation
my.pca$PC1
my.pca$rotation
my.pca$rotation[1]
my.pca$rotation[1,]
my.pca$rotation[,1]
# Exploratory analysis of the data
my.pca <- prcomp(my.data[,-21], scale.=T)
pc.1 <- my.pca$rotation[,1]
pc.2 <- my.pca$rotation[,2]
ggplot(my.data, aes(x=pc.1, y=pc.2, color=ANGLE.CLOSURE)) +
geom_point()
my.pcdata <- my.data[,-21] %*% my.pca$rotation[,1]
my.pcdata <- my.data[,-21] %*% my.pca$rotation
my.pcdata <- as.matrix(my.data[,-21]) %*% my.pca$rotation
View(my.pcdata)
my.pcdata <- as.data.frame(my.pcdata)
View(my.pcdata)
ggplot(my.data, aes(x=my.pcdata$PC1, y=my.pcdata$PC2, color=ANGLE.CLOSURE)) +
geom_point()
library(scatterplot3d)
scatterplot3d(my.pcdata$PC1, my.pcdata$PC2, my.pcdata$PC3)
scatterplot3d(my.pcdata$PC1, my.pcdata$PC2, my.pcdata$PC3,
color=my.data$ANGLE.CLOSURE)
scatterplot3d(my.pcdata$PC1, my.pcdata$PC2, my.pcdata$PC3,
color=as.numeric(my.data$ANGLE.CLOSURE))
ggplot(my.data, aes(x=ACA, y=ACV, color=ANGLE.CLOSURE)) +
geom_point()
